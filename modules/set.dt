#|
@module set

Concept macro for a set. Apart from the `Set` macro and concept macro,
the documentation in this module is for a generated set instance of
type `T`.

All of the functions that take `Iterator` arguments are defined for
`ReverseIterator`s as well, notwithstanding that there is no
documentation for those instances.

The `Set` type implements the following concepts:

  * `SimpleAssociativeContainer`;
  * `SortedAssociativeContainer`; and
  * `UniqueAssociativeContainer`.

Its iterators implement `ForwardIterator`.

Note that this implementation uses a non-self-balancing tree, so it's
pretty much for demonstration purposes only.

|#
(module set (attr cto))

(import cstdio)
(import macros)
(import cstdlib)
(import math)
(import concepts)
(import algorithms)
(import utility)
(import introspection)

#|
@macro Set

Expands to the concrete type name of the `Set` generated by way of
the concept macro.

@param T    The type node.
|#
(def Set
  (macro extern (T)
    (let ((typename (array-of 250 char)))
      (and (not (make-type-string "set" T typename))
           (return T))
      (def n (var auto (p DNode) (std.macros.mnfv pool typename)))
      (return n))))

(using-namespace std.macros
(using-namespace std.concepts

#|
@concept-macro Set

Expands to a `Set` definition over the relevant type. Note that `T`
must also implement `LessThanComparable`.

@param T    The type node.
|#
(std.concepts.def-concept-macro Set extern ((T EqualityComparable))
  (if (has-errors (qq std.concepts.implements (uq T) LessThanComparable))
      (return (qq std.concepts.implements (uq T) LessThanComparable))
      0)

  (let ((typename      (array-of 250 char))
        (etypename     (array-of 250 char))
        (nodetypename  (array-of 250 char)))
    ; Generate the type names and nodes, and register the main 'set'
    ; type.
    (and (not (make-type-string "set" T typename))
         (return (nullptr DNode)))
    (and (not (make-type-string "setnode" T nodetypename))
         (return (nullptr DNode)))
    (and (not (make-type-display-string "Set" T etypename))
         (return (nullptr DNode)))

    (def typenode     (var auto (p DNode) (std.macros.mnfv pool typename)))
    (def nodetypenode (var auto (p DNode) (std.macros.mnfv pool nodetypename)))
    (register-type typename etypename)

    (qq do

    (import derivations)
    (using-namespace std.macros
    (using-namespace std.concepts

    (def (uq nodetypenode)
      (struct extern
              ((value (uq T))
               (up    (p (uq nodetypenode)))
               (left  (p (uq nodetypenode)))
               (right (p (uq nodetypenode))))))

    #|
    @struct (Set T)

    The core set structure type.

    @linkage extern
    |#
    (def (uq typenode)
      (struct extern
              ((begin-node (p (p (uq nodetypenode)))))))

    #|
    @fn init

    Initialise a set.

    @param setp     A set pointer.
    @param-type     (p (Set T))
    @linkage        extern
    @return-type    bool
    |#
    (def init
      (fn extern bool ((setp (p (uq typenode))))
        (let ((bn  \ (malloc' 1 (uq nodetypenode)))
              (bnp \ (malloc' 1 (p (uq nodetypenode)))))
          (setf (:@ bn up)    bn)
          (setf (:@ bn left)  (nullptr (uq nodetypenode)))
          (setf (:@ bn right) (nullptr (uq nodetypenode)))
          (setf bnp bn)
          (setf (:@ setp begin-node) bnp)
          (return true)))) 

    #|
    @fn empty

    Determine whether the set is empty.

    @param setp     A set pointer.
    @param-type     (p (Set T))
    @linkage        extern
    @return-type    bool
    |#
    (def empty
      (fn extern bool ((setp (p (uq typenode))))
        (let ((bn \ (@ (@:@ setp begin-node))))
          (p= (@:@ bn up) bn))))

    #|
    @fn max-size

    Returns the number of elements that can be accommodated by the
    set.

    @param setp     A set pointer.
    @param-type     (p (Set T))
    @linkage        extern
    @return-type    size
    |#
    (def max-size
      (fn extern size ((setp (p (uq typenode))))
        (- (cast 0 size) (cast 1 size))))

    #|
    @macro value-type

    Expands to the underlying value type (i.e. `T`) of the set. This
    only uses the type node for dispatch purposes, so it's safe to
    call this with e.g. `(nullptr (Set T))` as the argument.

    @param setp     A type node.
    @param-type     (p (Set T))
    @linkage        extern
    |#
    (def value-type
      (macro extern ((setp (p (uq typenode))))
        (qq do (uq T))))

    #|
    @macro key-type

    Expands to the underlying key type of the set. Since `Set` is a
    `SimpleAssociativeContainer`, this returns the same type as
    `value-type`.

    @param setp     A type node.
    @param-type     (p (Set T))
    @linkage        extern
    |#
    (def key-type
      (macro extern ((setp (p (uq typenode))))
        (qq do (uq T))))

    #|
    @macro size-type

    Expands to the underlying size type of the set.

    @param setp     A type node.
    @param-type     (p (Set T))
    @linkage        extern
    |#
    (def size-type
      (macro extern ((setp (p (uq typenode))))
        (qq do size)))

    #|
    @macro difference-type

    Expands to the underlying iterator difference type of the set.

    @param setp     A type node.
    @param-type     (p (Set T))
    @linkage        extern
    |#
    (def difference-type
      (macro extern ((setp (p (uq typenode))))
        (qq do ptrdiff)))

    #|
    @struct (Iterator (Set T))

    @linkage extern
    |#
    (def (Iterator (Set (uq T)))
      (struct extern ((setp    (p (uq typenode)))
                      (element (p (uq nodetypenode))))))

    #|
    @fn end

    Returns the iterator representing the end of the set (sentinel).

    @param setp     A set pointer.
    @param-type     (p (Set T))
    @linkage        extern
    @return-type    (Iterator (Set T))
    |#
    (def end
      (fn extern (Iterator (Set (uq T))) ((setp (p (uq typenode))))
        (let ((thing (Iterator (Set (uq T)))))
          (setf (: thing element) (nullptr (uq nodetypenode)))
          (setf (: thing setp)    setp)
          (return thing))))

    #|
    @fn begin

    Returns the iterator for the first set element.

    @param setp     A set pointer.
    @param-type     (p (Set T))
    @linkage        extern
    @return-type    (Iterator (Set T))
    |#
    (def begin
      (fn extern (Iterator (Set (uq T))) ((setp (p (uq typenode))))
        (let ((thing (Iterator (Set (uq T))) 
                        ((element (@ (@:@ setp begin-node)))
                         (setp    setp))))
          (if (empty setp)
              (do (return (end setp)))
              0)
          (if (null (@: thing element))
              (do (return thing))
              0)
          (while (not (null (@:@ (@: thing element) left)))
              (setf (: thing element)
                    (@:@ (@: thing element) left)))
          (return thing))))

    #|
    @macro value-type

    Expands to the underlying value type (i.e. `T`) of the iterator.

    @param iter     A type node.
    @param-type     (p (Iterator (Set T)))
    @linkage        extern
    |#
    (def value-type
      (macro extern ((setiter (p (Iterator (Set (uq T))))))
        (qq do (uq T))))

    #|
    @fn @source

    Returns the iterator's value.

    @param iter     An iterator.
    @param-type     (Iterator (Set T))
    @linkage        extern
    @return-type    T
    |#
    (def @source
      (fn extern (uq T) ((iter (Iterator (Set (uq T)))))
        (@:@ (@: iter element) value)))

    #|
    @fn source

    Returns a pointer to the iterator's value.

    @param iter     An iterator.
    @param-type     (Iterator (Set T))
    @linkage        extern
    @return-type    (p T)
    |#
    (def source
      (fn extern (p (uq T)) ((iter (Iterator (Set (uq T)))))
        (:@ (@: iter element) value)))

    #|
    @fn successor

    Returns the iterator for the position that follows the argument
    iterator.

    @param iter     An iterator.
    @param-type     (Iterator (Set T))
    @linkage        extern
    @return-type    (Iterator (Set T))
    |#
    (def successor         
      (fn extern (Iterator (Set (uq T))) ((iter (Iterator (Set (uq T)))))
        (if (and (not (null (@:@ (@: iter element) up)))
                 (null (@:@ (@: iter element) right)))
            (do
              (while (< (@:@ (@:@ (@: iter element) up) value)
                        (@:@ (@: iter element) value))
                (setf (: iter element) (@:@ (@: iter element) up))
                (and (null (@:@ (@: iter element) up))
                     (break)))
              
              (if (null (@:@ (@: iter element) up))
                  (do (setf (: iter element) (nullptr (uq nodetypenode)))
                      (return iter))
                  (do (setf (: iter element) (@:@ (@: iter element) up))
                      (return iter))))
            (if (null (@:@ (@: iter element) right))
                (do (setf (: iter element) (nullptr  (uq nodetypenode)))
                    (return iter))
                (do
                  (let ((rn \ (@:@ (@: iter element) right)))
                    (while (not (null (@:@ rn left)))
                      (setv rn (@:@ rn left)))
                    (setf (: iter element) rn)
                    (return iter)))))))

    #|
    @fn =

    @param iter1    The first iterator.
    @param-type     (Iterator (Set T))
    @param iter2    The second iterator.
    @param-type     (Iterator (Set T))
    @linkage        extern
    @return-type    bool
    |#
    (def =
      (fn extern bool ((iter1 (Iterator (Set (uq T))))
                       (iter2 (Iterator (Set (uq T)))))
        (let ((i1isend bool (null (@: iter1 element)))
              (i2isend bool (null (@: iter2 element))))
          (if (and i1isend i2isend)
              true
          (if i1isend
              false
          (if i2isend
              false
          (= (@:@ (@: iter1 element) value) 
             (@:@ (@: iter2 element) value))))))))

    (implement Type (Iterator (Set (uq T))))
    (instantiate != (Iterator (Set (uq T))))

    #|
    @fn <

    @param iter1    The first iterator.
    @param-type     (Iterator (Set T))
    @param iter2    The second iterator.
    @param-type     (Iterator (Set T))
    @linkage        extern
    @return-type    bool
    |#
    (def <
      (fn extern bool ((iter1 (Iterator (Set (uq T))))
                       (iter2 (Iterator (Set (uq T)))))
        (let ((i1isend bool (= (@ (cast (# iter1) (p int))) 0))
              (i2isend bool (= (@ (cast (# iter2) (p int))) 0)))
          (if (and i1isend i2isend)
              false
          (if i1isend
              false
          (if i2isend
              true
          (< (@:@ (@: iter1 element) value) 
             (@:@ (@: iter2 element) value))))))))

    (mfor F (<= > >=)
      (instantiate F (Iterator (Set (uq T)))))
    (implement LessThanComparable (Iterator (Set (uq T))))

    #|
    @struct (ReverseIterator (Set T))

    @linkage extern
    |#
    (def (ReverseIterator (Set (uq T)))
      (struct extern ((element (p (uq nodetypenode)))
                      (setp    (p (uq typenode))))))

    #|
    @fn rend

    Returns the iterator representing the beginning of the set (sentinel).

    @param setp     A set pointer.
    @param-type     (p (Set T))
    @linkage        extern
    @return-type    (ReverseIterator (Set T))
    |#
    (def rend
      (fn extern (ReverseIterator (Set (uq T))) ((setp (p (uq typenode))))
        (let ((thing (ReverseIterator (Set (uq T)))))
          (setf (: thing element) (nullptr (uq nodetypenode)))
          (setf (: thing setp)    setp)
          (return thing))))

    #|
    @fn rbegin

    Returns the iterator for the last set element.

    @param setp     A set pointer.
    @param-type     (p (Set T))
    @linkage        extern
    @return-type    (ReverseIterator (Set T))
    |#
    (def rbegin
      (fn extern (ReverseIterator (Set (uq T))) ((setp (p (uq typenode))))
        (let ((thing (ReverseIterator (Set (uq T))) 
                        ((element (@ (@:@ setp begin-node)))
                         (setp    setp))))
          (if (null (@: thing element))
              (return thing)
              0)
          (while (not (null (@:@ (@: thing element) left)))
              (setf (: thing element)
                    (@:@ (@: thing element) left)))
          (return thing))))

    (def value-type
      (macro extern ((setiter (p (ReverseIterator (Set (uq T))))))
        (qq do (uq T))))

    (def @source
      (fn extern (uq T) ((iter (ReverseIterator (Set (uq T)))))
        (@:@ (@: iter element) value)))

    (def source
      (fn extern (p (uq T)) ((iter (ReverseIterator (Set (uq T)))))
        (:@ (@: iter element) value)))

    (def successor         
      (fn extern (ReverseIterator (Set (uq T))) 
                        ((iter (ReverseIterator (Set (uq T)))))
        (if (and (not (null (@:@ (@: iter element) up)))
                 (null (@:@ (@: iter element) left)))
            (do
              (while (< (@:@ (@:@ (@: iter element) up) value)
                        (@:@ (@: iter element) value))
                (setf (: iter element) (@:@ (@: iter element) up))
                (and (null (@:@ (@: iter element) up))
                     (break)))
              
              (if (null (@:@ (@: iter element) up))
                  (do (setf (: iter element) (nullptr (uq nodetypenode)))
                      (return iter))
                  (do (setf (: iter element) (@:@ (@: iter element) up))
                      (return iter))))
            (if (null (@:@ (@: iter element) left))
                (do (setf (: iter element) (nullptr  (uq nodetypenode)))
                    (return iter))
                (do
                  (let ((rn \ (@:@ (@: iter element) left)))
                    (while (not (null (@:@ rn right)))
                      (setv rn (@:@ rn right)))
                    (setf (: iter element) rn)
                    (return iter)))))))
                    
    (def =
      (fn extern bool ((iter1 (ReverseIterator (Set (uq T))))
                       (iter2 (ReverseIterator (Set (uq T)))))
        (let ((i1isend bool (= (@ (cast (# iter1) (p int))) 0))
              (i2isend bool (= (@ (cast (# iter2) (p int))) 0)))
          (if (and i1isend i2isend)
              true
          (if i1isend
              false
          (if i2isend
              false
          (= (@:@ (@: iter1 element) value) 
             (@:@ (@: iter2 element) value))))))))

    (implement Type (ReverseIterator (Set (uq T))))
    (instantiate != (ReverseIterator (Set (uq T))))

    (def <
      (fn extern bool ((iter1 (ReverseIterator (Set (uq T))))
                       (iter2 (ReverseIterator (Set (uq T)))))
        (let ((i1isend bool (= (@ (cast (# iter1) (p int))) 0))
              (i2isend bool (= (@ (cast (# iter2) (p int))) 0)))
          (if (and i1isend i2isend)
              false
          (if i1isend
              false
          (if i2isend
              true
          (< (@:@ (@: iter1 element) value) 
             (@:@ (@: iter2 element) value))))))))

    (mfor F (<= > >=)
      (instantiate F (ReverseIterator (Set (uq T)))))
    (implement LessThanComparable (ReverseIterator (Set (uq T))))

    #|
    @fn insert

    Insert a new element into the set.

    @param setp     A set pointer.
    @param-type     (p (Set T))
    @param val      The value to insert into the set.
    @param-type     T
    @linkage        extern
    @return-type    bool
    |#
    (def insert
      (fn extern bool ((setp   (p (uq typenode)))
                       (newval (uq T)))
        (if (empty setp)
            (do (setf (:@ (@ (@:@ setp begin-node)) value)
                      newval)
                (setf (:@ (@ (@:@ setp begin-node)) up)
                      (nullptr (uq nodetypenode)))
                (return true))
            (let ((newnodep \ (malloc' 1 (uq nodetypenode))))
              (setf (:@ newnodep value) newval)
              (setf (:@ newnodep up)    (nullptr (uq nodetypenode)))
              (setf (:@ newnodep left)  (nullptr (uq nodetypenode)))
              (setf (:@ newnodep right) (nullptr (uq nodetypenode)))
              (let ((cn    \ (@ (@:@ setp begin-node)))
                    (newnp \ (nullptr (p (uq nodetypenode)))))
                (while (!= newval (@:@ cn value))
                  (if (< newval (@:@ cn value))
                      (do (if (null (@:@ cn left))
                              (do (setv newnp (# (@:@ cn left)))
                                  (break))
                              (setv cn (@:@ cn left))))
                      (do (if (null (@:@ cn right))
                              (do (setv newnp (# (@:@ cn right)))
                                  (break))
                              (setv cn (@:@ cn right))))))
                
                (if (not (null newnp))
                    (do (setf newnp newnodep)
                        (setf (:@ newnodep up) cn) 0)
                    (do (setf (:@ cn value) newval) 0))
                (return true))))))

    #|
    @fn find

    Find an element within the set, and return the iterator for its
    position.

    @param setp     A set pointer.
    @param-type     (p (Set T))
    @param val      The value to find in the set.
    @param-type     T
    @linkage        extern
    @return-type    (Iterator (Set T))
    |#
    (def find
      (fn extern (Iterator (Set (uq T))) 
                          ((setp   (p (uq typenode)))
                           (value  (uq T)))
        (let ((cn \ (@ (@:@ setp begin-node))))
            (and (null cn)
                 (return (end setp)))
            (while (!= value (@:@ cn value))
              (if (< value (@:@ cn value))
                  (do (if (null (@:@ cn left))
                          (return (end setp))
                          (setv cn (@:@ cn left))))
                  (do (if (null (@:@ cn right))
                          (return (end setp))
                          (setv cn (@:@ cn right))))))
            (and (null cn)
                 (return (end setp)))
            (return ((Iterator (Set (uq T))) ((element cn)
                                        (setp setp)))))))

    #|
    @fn erase

    Erase an element from the set, by specifying the iterator for its
    position.

    @param iter     The iterator.
    @param-type     (Iterator (Set T))
    @linkage        extern
    @return-type    bool
    |#
    (def erase
      (fn extern bool ((iter (Iterator (Set (uq T)))))
        (let ((node  \ (@: iter element))
              (setp  \ (@: iter setp))
              (up    \ (@:@ node up))
              (left  \ (@:@ node left))
              (right \ (@:@ node right))
              (nullp \ (nullptr (uq nodetypenode)))
              (pptr  \ (if (not (null up))
                           (if (p= node (@:@ up left))
                               (:@ up left)
                               (:@ up right))
                           (nullptr (p (uq nodetypenode)))))
              (has-pptr \ (not (null pptr)))
              (is-root  \ (null up)))
          ; If this is the root element, and it's already empty, then
          ; return false.
          (if (p= up node)
              (return false)
              0)
          ; If this element has nothing underneath it, then destroy
          ; the element (if required) and null the relevant pointer
          ; in the next-highest node. If it's the root node as well,
          ; then set its up pointer to itself, to indicate that it
          ; is empty.
          (if (and (null left) (null right))
              (do (if has-pptr (setf pptr nullp) true)
                  (if is-root (setf (:@ node up) node) true)
                  (let ((value \ (:@ node value)))
                    (destroy value)
                    (if (not is-root) (do (free' node) 0) 0)
                    (goto end)))
              0)
          ; If there is a left element or a right element, but not
          ; both, then make the parent point to that element and
          ; destroy the value.
          (if (and (null left) (not (null right)))
              (do (if has-pptr (do (setf pptr right)
                                   (setf (:@ right up) up))
                               (setf (:@ right up) nullp))
                  (let ((value \ (:@ node value)))
                    (destroy value)
                    (free' node)
                    (goto end)))
              0)
          (if (and (null right) (not (null left)))
              (do (if has-pptr (do (setf pptr left)
                                   (setf (:@ left up) up))
                               (setf (:@ left up) nullp))
                  (let ((value \ (:@ node value)))
                    (destroy value)
                    (free' node)
                    (goto end)))
              0)
          ; Make the parent link to this node's left node (LN).
          (if has-pptr
              (do (setf pptr left)
                  (setf (:@ left up) up))
              (setf (:@ left up) nullp))
          ; Find the rightmost leaf node of LN (RLN).
          (def rln (var auto \ left))
          (while (not (null (@:@ rln right)))
            (setv rln (@:@ rln right)))
          ; Make RLN point rightwards to this node's right node.
          (setf (:@ rln right) right)
          ; Destroy the node.
          (let ((value \ (:@ node value)))
            (destroy value)
            (free' node))
          
          (label end)
          
          ; Final part: if the node being removed was the root node,
          ; update the root node pointer in the set. It will be
          ; left, if left exists, otherwise it will be right. (If
          ; the root has nothing underneath it, then do not change
          ; the root node pointer: its 'up' pointer will point to
          ; itself so as to indicate that the set is empty.)
            (if (and is-root (not (and (null left) (null right))))
                (setf (@:@ setp begin-node)
                      (if (not (null left))
                          left
                          right))
                true)

          (return true))))
      
    #|
    @fn erase

    Erase an element from the set, by value.

    @param setp     A set pointer.
    @param-type     (p (Set T))
    @param val      The value to remove from the set.
    @param-type     T
    @linkage        extern
    @return-type    bool
    |#
    (def erase
      (fn extern bool ((setp (p (uq typenode)))
                       (v (uq T)))
        (let ((iter \ (find setp v)))
          (if (= (end setp) iter)
                 false
                 (erase iter)))))

    #|
    @fn lower-bound

    Find the lower bound for a given value.

    @param setp     A set pointer.
    @param-type     (p (Set T))
    @param val      The value for which the lower bound should be found.
    @param-type     T
    @linkage        extern
    @return-type    (Iterator (Set T))
    |#
    (def lower-bound
      (fn extern (Iterator (Set (uq T))) 
                        ((setp (p (uq typenode)))
                         (value (uq T)))
        (let ((cn \ (@ (@:@ setp begin-node))))
            (and (null cn)
                 (return (end setp)))
            (while (!= value (@:@ cn value))
              (if (< value (@:@ cn value))
                  (do (if (null (@:@ cn left))
                          (break)
                          (setv cn (@:@ cn left))))
                  (do (if (null (@:@ cn right))
                          (break)
                          (setv cn (@:@ cn right))))))
            (and (null cn)
                 (return (end setp)))
            (return ((Iterator (Set (uq T))) ((element cn)
                                        (setp setp)))))))

    #|
    @fn upper-bound

    Find the upper bound for a given value.

    @param setp     A set pointer.
    @param-type     (p (Set T))
    @param val      The value for which the upper bound should be found.
    @param-type     T
    @linkage        extern
    @return-type    (Iterator (Set T))
    |#
    (def upper-bound
      (fn extern (Iterator (Set (uq T))) 
                        ((setp (p (uq typenode)))
                         (value (uq T)))
        (let ((lb \ (lower-bound setp value)))
          (if (= lb (end setp))                   lb
          (if (and (!= value (@source lb))
                   (= (successor lb) (end setp))) (end setp)
                                                  (successor lb))))))

    #|
    @fn count

    Return the number of times that the value appears in the set. For
    a `UniqueAssociativeContainer` such as `Set`, this can only return
    1 or 0, depending on whether the element is present in the set.

    @param setp     A set pointer.
    @param-type     (p (Set T))
    @param val      The value for which the count should be determined.
    @param-type     T
    @linkage        extern
    @return-type    size
    |#
    (def count
      (fn extern size ((setp (p (uq typenode)))
                       (v (uq T)))
        (let ((iter \ (find setp v)))
          (cast (if (= (end setp) iter) 0 1) size))))

    #|
    @fn size

    Return the number of elements in the set.

    @param setp     A set pointer.
    @param-type     (p (Set T))
    @linkage        extern
    @return-type    size
    |#
    (def size
      (fn extern size ((setp (p (uq typenode))))
        (let ((b \ (begin setp))
              (e \ (end setp))
              (c size 0))
          (while (!= b e)
            (setv c (+ c (cast 1 size)))
            (setv b (successor b)))
          c)))

    (def clear
      (fn extern void ((setnp (p (uq nodetypenode))))
        (if (not (null (@:@ setnp left)))
            (do (clear (@:@ setnp left)) 0)
            0)
        (if (not (null (@:@ setnp right)))
            (do (clear (@:@ setnp right)) 0)
            0)
        (let ((value \ (:@ setnp value)))
          (destroy value))
        (free' setnp)
        (return)))

    #|
    @fn clear

    Remove all of the elements from the set.

    @param setp     The set pointer.
    @param-type     (p (Set T))
    @linkage        extern
    @return-type    bool
    |#
    (def clear
      (fn extern void ((setp (p (uq typenode))))
        (if (not (null (@ (@:@ setp begin-node))))
            (do (clear (@ (@:@ setp begin-node))) 0)
            0)
        (init setp)
        (return)))

    #|
    @fn swap

    @param set1     The first set pointer.
    @param set2     The second set pointer.
    @param-type     (p (Set T))
    @param-type     (p (Set T))
    @linkage        extern
    @return-type    void
    |#
    (def swap
      (fn extern void ((set1 (p (uq typenode)))
                       (set2 (p (uq typenode))))
        (let ((bn1 \ (@:@ set1 begin-node))
              (bn2 \ (@:@ set2 begin-node)))
          (setf (:@ set1 begin-node) bn2)
          (setf (:@ set2 begin-node) bn1)
          (return))))

    (def setf-copy (fn extern bool ((dst (p (uq typenode)))
                                    (src (p (uq typenode))))
      (init dst)
      (let ((b \ (begin src))
            (e \ (end   src)))
        (for true (!= b e) (setv b (successor b))
          (insert dst (@source b))))
      true))

    (def setf-assign (fn extern bool ((dst (p (uq typenode)))
                                      (src (p (uq typenode))))
      (clear dst)
      (setf-copy dst src)))

    (implement Container (uq typenode))
    (implement Type (p (uq typenode)))
    (mfor F (= <)
      (instantiate F (uq typenode)))
    (mfor F (!= <= > >=)
      (instantiate F (p (uq typenode))))

    (mfor F (= != < > <= >=)
      (def F
        (fn extern bool ((fst (uq typenode))
                         (snd (uq typenode)))
          (F (# fst) (# snd)))))

    (implement EqualityComparable (uq typenode))
    (implement LessThanComparable (uq typenode))

    (def destroy
      (fn extern void ((setp (p (uq typenode))))
        (clear setp)
        (return)))

    (implement Type (Iterator (Set (uq T))))
    (implement Type (ReverseIterator (Set (uq T))))
    (instantiate swap (Iterator (Set (uq T))))
    (instantiate swap (ReverseIterator (Set (uq T))))
    (implement ForwardIterator (Iterator (Set (uq T))))
    (implement ForwardIterator (ReverseIterator (Set (uq T))))
    (implement SimpleAssociativeContainer (uq typenode))
    (implement SortedAssociativeContainer (uq typenode))
    (implement UniqueAssociativeContainer (uq typenode))
    ))
)))

))

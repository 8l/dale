(import cstdio)
(import cstdlib)
(import cstring)

(import unistd)
(import vector)
(import derivations)
(import algorithms)

;; Types and instantiations.

(def member-def
  (struct intern ((name (p char))
                  (type (p char)))))

(def struct-def
  (struct intern ((name    (p char))
                  (linkage (p char))
                  (info    (p char))
                  (members (p member-def)))))

(std.concepts.implement Struct struct-def)
(std.concepts.implement PreferRefs struct-def)
(std.concepts.instantiate swap struct-def)
(std.concepts.implement Assignable struct-def)

(def = (fn intern bool ((a (ref (const struct-def)))
                        (b (ref (const struct-def))))
  (p= (@:@ a name) (@:@ b name))))

(std.concepts.instantiate != struct-def)

(def < (fn intern bool ((a (ref (const struct-def)))
                        (b (ref (const struct-def))))
  (p< (@:@ a name) (@:@ b name))))

(std.concepts.instantiate <= struct-def)
(std.concepts.instantiate >  struct-def)
(std.concepts.instantiate >= struct-def)

(std.concepts.implement EqualityComparable struct-def)
(std.concepts.implement LessThanComparable struct-def)
(std.concepts.instantiate Vector struct-def)

(def proc-type
  (enum intern int (FN MACRO CONCEPT-MACRO)))

(def param-def
  (struct intern ((name (p char))
                  (type (p char))
                  (info (p char)))))
(def proc-def
  (struct intern ((name    (p char))
                  (linkage (p char))
                  (returns (p char))
                  (info    (p char))
                  (params  (p param-def)))))

(std.concepts.implement Struct proc-def)
(std.concepts.implement PreferRefs proc-def)
(std.concepts.instantiate swap proc-def)
(std.concepts.implement Assignable proc-def)

(def = (fn intern bool ((a (ref (const proc-def)))
                        (b (ref (const proc-def))))
  (p= (@:@ a name) (@:@ b name))))

(std.concepts.instantiate != proc-def)

(def < (fn intern bool ((a (ref (const proc-def)))
                        (b (ref (const proc-def))))
  (p< (@:@ a name) (@:@ b name))))

(std.concepts.instantiate <= proc-def)
(std.concepts.instantiate >  proc-def)
(std.concepts.instantiate >= proc-def)

(std.concepts.implement EqualityComparable proc-def)
(std.concepts.implement LessThanComparable proc-def)
(std.concepts.instantiate Vector proc-def)

;; Common functions.

; Read a line from standard input, up to limit characters, into buf.
(def get-line (fn intern int ((buf (p char)) (limit int))
  (def b (var auto int 0))
  (def c (var auto int 0))
  (while (< c limit)
    (setv b (fread (cast buf (p void)) 1 1 stdin))
    (and (= 0 b)
         (do (setf buf #\NULL)
             (return c)))
    (and (= #\NEWLINE (@ buf))
         (do (setf (p+ buf 1) #\NULL)
             (incv c)
             (return c)))
    (setv buf (p+ buf b))
    (incv c))
  (return c)))

; Copy the portion of str between the strings begin and end into buf.
(def get-element (fn intern bool ((str   (p (const char)))
                                  (begin (p (const char)))
                                  (end   (p (const char)))
                                  (buf   (p char)))
  (let ((fb \ (if (null begin) str (strstr str begin))))
    (and (null fb) (return false))
    (let ((fbe \ (p+ fb (if (null begin) (cast 0 size) (strlen begin))))
          (fe  \ (strstr fbe end)))
      (strncpy buf fbe (cast (p- fe fbe) int))
      (setf ($ buf (cast (p- fe fbe) int)) #\NULL)
      (return true)))))

; Read from standard input into linebuf, and copying to buf, until a
; line containing the specified string is reached.
(def get-until (fn intern void ((linebuf  (p char))
                                (buf      (p char))
                                (stop-str (p (const char))))
  (let ((linebufp   (p char))
        (past-first \ false)
        (whitespace \ 0)
        (c          \ 0))
    (while (do (setv c (get-line linebuf 255))
               (and (!= c 0)
                    (p= (nullptr char) (strstr linebuf stop-str))))
      (setv linebufp ($ linebuf 0))
      (if (not past-first)
          (do (while (= #\SPACE (@$ linebufp 0))
                (do (incv whitespace)
                    (setv linebufp (p+ linebufp 1))))
              (setv past-first true))
      (if (> c whitespace)
          (setv linebufp (p+ linebufp whitespace))
          true))
      (strcat buf linebufp))
    (return))))

; Return a pointer to the first char within str past any initial whitespace.
(def remove-whitespace (fn intern (p char) ((str (p (const char))))
  (while (= (@ str) #\SPACE)
    (setv str (p+ str 1)))
  (return str)))

; Print str to stderr and exit.
(def err (fn intern bool ((str (p (const char))))
  (fprintf stderr "error: %s.\n" str)
  (exit 1)
  (return false)))

;; Structs.

(def struct-defs (var intern (Vector struct-def)))

; Add a struct definition to the list of struct definitions.
(def add-struct-def (fn intern void ((name    (p char))
                                     (linkage (p char))
                                     (info    (p char))
                                     (members (p member-def)))
  (let ((nsd struct-def ((name    name)
                         (linkage (remove-whitespace linkage))
                         (info    info)
                         (members members))))
    (push-back struct-defs nsd)
    (return))))

; Print the members of a struct definition to standard output.
(def print-members (fn intern void ((strd (p struct-def)))
  (let ((members \ (@:@ strd members)))
    (and (or (null members) (null (@:@ members name)))
         (do (printf " N/A\n")
             (return)))
    (while (and (not (null members))
                (not (null (@:@ members name))))
      (printf "  * `(%s %s)`\n"
              (@:@ members name)
              (remove-whitespace (@:@ members type))
      (setv members (p+ members 1))))
    (printf "\n"))
    (return)))

; Print a struct definition to standard output.
(def print-struct (fn intern void ((strd (p struct-def)))
  (let ((linkage \ (@:@ strd linkage))
        (name    \ (@:@ strd name)))
    (and (= 0 (cast (strlen linkage) int))
         (setv linkage "N/A"))
    (printf "#### `%s`\n\n" name)
    (printf "Linkage: `%s`\n" linkage)
    (printf "Members:")
    (print-members strd)
    (printf "\n")
    (printf "%s\n" (@:@ strd info))
    (return))))

; Parse a struct definition and add it to the list, beginning with buf
; and using standard input for the subsequent lines.
(def parse-struct (fn intern bool ((buf (p (const char))))
  (def name (var auto (p char) (malloc' 255 char)))
  (def info (var auto (p char) (malloc' 2048 char)))
  (def linkage (var auto (p char) (malloc' 32 char)))
  (setf ($ info 0) #\NULL)
  (def n (var auto \ (get-element buf "@struct " "\n" name)))
  (and (not n) (err "no struct name found"))

  (def mybuf (var auto (array-of 255 char)))
  (def mybufp (var auto (p char) ($ mybuf 0)))
  (def c (var auto \ 1))
  (def linecount (var auto \ 0))
  (def ws (var auto \ 0))
  (get-line mybuf 255)

  (get-until mybuf info "@")

  (while (and (!= c 0)
              (not (p= (nullptr char) (strstr mybuf "@"))))
    (setv mybufp ($ mybuf 0))
    (if (> c ws)
        (setv mybufp (p+ mybufp ws))
        true)
    (setv n (get-element mybufp "@linkage " "\n" linkage))
    (setv c (get-line mybuf 255)))

  (def members (var auto \ (malloc' 10 member-def)))
  (def memberi (var auto \ 0))
  (def memberbuf (var auto (array-of 255 char)))

  (setf (: (@$ members memberi) name) (nullptr char))

  (add-struct-def name linkage info members)
  true))

;; Functions, macros, and concept macros.

(def fn-defs (var intern (Vector proc-def)))
(def macro-defs (var intern (Vector proc-def)))
(def concept-macro-defs (var intern (Vector proc-def)))

; Add a procedure definition to a list of procedure definitions.
(def add-proc-def (fn intern void ((name    (p char))
                                   (linkage (p char))
                                   (returns (p char))
                                   (info    (p char))
                                   (params  (p param-def))
                                   (type    proc-type))
  (def procdef
    (var auto proc-def
      ((name    name)
       (linkage (remove-whitespace linkage))
       (returns (remove-whitespace returns))
       (info    info)
       (params  params))))
  (if (= type (proc-type FN))
      (push-back fn-defs procdef)
  (if (= type (proc-type MACRO))
      (push-back macro-defs procdef)
      (push-back concept-macro-defs procdef)))
  (return)))

; Print a procedure parameter to standard output.
(def print-param (fn intern void ((param (p param-def)))
  (if (not (null (@:@ param type)))
      (printf "  * `(%s %s)`: %s\n"
              (@:@ param name)
              (remove-whitespace (@:@ param type))
              (remove-whitespace (@:@ param info)))
      (printf "  * `%s`: %s\n"
              (@:@ param name)
              (remove-whitespace (@:@ param info))))
  (return)))

; Print a procedure to standard output.
(def print-proc (fn intern void ((fnd (p proc-def)))
  (def linkage (var auto \ (@:@ fnd linkage)))
  (and (= 0 (cast (strlen linkage) int))
       (setv linkage "N/A"))
  (def params (var auto \ (@:@ fnd params)))
  (printf "#### `%s`\n\n" (@:@ fnd name))
  (printf "Linkage: `%s`\n" linkage)
  (def returns (var auto \ (@:@ fnd returns)))
  (and (and (not (null returns))
            (!= 0 (cast (strlen returns) int)))
       (do (printf "Returns: `%s`\n" returns) true))
  (printf "Parameters:")
  (if (null params)
      (printf " N/A\n")
      (do (printf "\n\n")
          (while (and (not (null params))
                      (not (null (@:@ params name))))
            (print-param params)
            (setv params (p+ params 1)))
          (printf "\n")))
  (printf "\n")
  (printf "%s\n" (@:@ fnd info))
  (return)))

; Parse a procedure definition and add it to the list, beginning with
; buf and using standard input for the subsequent lines.
(def parse-fn (fn intern bool ((buf (p (const char)))
                               (type proc-type))
  (def name (var auto (p char) (malloc' 255 char)))
  (def info (var auto (p char) (malloc' 2048 char)))
  (def linkage (var auto (p char) (malloc' 32 char)))
  (def returns (var auto (p char) (malloc' 255 char)))
  (setf ($ info 0) #\NULL)
  (def n (var auto \
    (get-element buf (if (= type (proc-type FN))
                        "@fn "
                    (if (= type (proc-type MACRO))
                        "@macro "
                        "@concept-macro "))
                "\n" name)))
  (and (not n) (err "no fn name found"))

  (def mybuf (var auto (array-of 255 char)))
  (def mybufp (var auto (p char) ($ mybuf 0)))
  (def c (var auto \ 1))
  (def linecount (var auto \ 0))
  (def ws (var auto \ 0))
  (get-line mybuf 255)

  (get-until mybuf info "@")

  (def params (var auto \ (malloc' 10 param-def)))
  (def parami (var auto \ 0))
  (def parambuf (var auto (array-of 255 char)))

  (while (and (!= c 0)
              (not (p= (nullptr char) (strstr mybuf "@"))))
    (setv mybufp ($ mybuf 0))
    (if (> c ws)
        (setv mybufp (p+ mybufp ws))
        true)
    (setv n (get-element mybufp "@linkage " "\n" linkage))
    (and (not n)
         (setv n (get-element mybufp "@return-type " "\n" returns)))
    (and (not n)
         (do (setv n (get-element mybufp "@param " " " parambuf))
             (and n
                 (do (def paramname (var auto \ (malloc' 255 char)))
                     (def paramtype (var auto \ (malloc' 255 char)))
                     (def paraminfo (var auto \ (malloc' 255 char)))
                     (strcpy paramname parambuf)
                     (setv mybufp (p+ (strstr mybufp "@param ")
                                      (+ (cast 7 size)
                                         (strlen paramname))))
                     (setv n (get-element mybufp " " "\n" paraminfo))
                     (and (not n) (err "no parameter info found"))
                     (setv c (get-line mybuf 255))
                     (and (= c 0) (err "no parameter type line found"))
                     (setv mybufp ($ mybuf 0))
                     (setv n (get-element mybufp "@param-type " "\n" paramtype))
                     (setf ($ params parami) ((name paramname)
                                              (type (if (not n)
                                                        (nullptr char)
                                                        paramtype))
                                              (info paraminfo)))
                     (incv parami)))))
    ; todo: parsing other parts goes here.
    (setv c (get-line mybuf 255)))

  (setf (: (@$ params parami) name) (nullptr char))

  (add-proc-def name linkage returns info params type)
  true))

;; Main.

(def main (fn extern-c int (void)
  (init struct-defs 1)
  (init fn-defs 10)
  (init macro-defs 10)
  (init concept-macro-defs 10)

  (def buf (var auto (array-of 255 char)))
  (get-line buf 255)
  (get-line buf 255)
  (def module-name (var auto (array-of 255 char)))
  (def n (var auto \ (get-element buf "@module " "\n" module-name)))
  (and (not n) (err "unable to find module name"))

  (printf "### Details\n\nModule: %s\n\n" module-name)
  (printf "### Description\n")
  (while (do (get-line buf 255) (!= 0 (strcmp buf "|#\n")))
    (printf "%s" buf))

  (def c (var auto \ 1))

  (while (!= c 0)
    (while (do (setv c (get-line buf 255))
               (and (!= c 0)
                    (p= (nullptr char) (strstr buf "#|\n")))) true)
    (and (!= c 0)
         (do
            (get-line buf 255)
            (def type (var auto (array-of 255 char)))
            (setv n (get-element buf "@" " " type))
            (and (not n) (err "invalid definition"))
            (if (= 0 (strcmp type "struct"))
                (parse-struct buf)
            (if (= 0 (strcmp type "fn"))
                (parse-fn buf (proc-type FN))
            (if (= 0 (strcmp type "macro"))
                (parse-fn buf (proc-type MACRO))
            (if (= 0 (strcmp type "concept-macro"))
                (parse-fn buf (proc-type CONCEPT-MACRO))
                true)))))))

  (and (not (empty struct-defs))
       (do (printf "\n\n### Structs\n\n")
           (let ((b \ (begin struct-defs))
                 (e \ (end   struct-defs)))
             (for true (!= b e) (setv b (successor b))
               (print-struct (source b))))
           true))

  (and (not (empty fn-defs))
       (do (printf "\n\n### Functions\n\n")
           (let ((b \ (begin fn-defs))
                 (e \ (end   fn-defs)))
             (for true (!= b e) (setv b (successor b))
               (print-proc (source b))))
           true))

  (and (not (empty concept-macro-defs))
       (do (printf "\n\n### Concept macros\n\n")
           (let ((b \ (begin concept-macro-defs))
                 (e \ (end   concept-macro-defs)))
             (for true (!= b e) (setv b (successor b))
               (print-proc (source b))))
           true))

  (and (not (empty macro-defs))
       (do (printf "\n\n### Macros\n\n")
           (let ((b \ (begin macro-defs))
                 (e \ (end   macro-defs)))
             (for true (!= b e) (setv b (successor b))
               (print-proc (source b))))
           true))
  0))
